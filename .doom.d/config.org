#+title: Doom emacs config.el
#+author: Sasa Salmen
#+email: sasinhe@gmail.com


* A quick introduction and motivation
Hi! My name is Sasa and this is my configuration for doom Emacs (or a scrapping of a
lot of other configuration files that I found on the internet).
A special thanks to [[https://tecosaur.github.io/emacs-config/config.html][Tecosaur]], for their (I don't know their pronouns, so I'll go
with *They/Them*) configuration file that inspired me (and
inspired the most part of this document).

Hope you find it useful!

* First steps
I'm using (and you should too!) lexical binding for loading this file quicker.

#+begin_src emacs-lisp :tangl yes
;;; config.el -*- lexical-binding: t; -*-
#+end_src

** Personal information
Let's have some personal info.

#+begin_src emacs-lisp :tangle yes
(setq user-full-name "Sasa Salmen"
      user-mail-address "sasinhe@gmail.com")
#+end_src


** Better defaults
*** Simple settings
I'm selecting the best of both [[https://tecosaur.github.io/emacs-config/config.html][Tecosaur]] and [[https://github.com/angrybacon/dotemacs/blob/master/dotemacs.org#use-better-defaults][angrybacon]] defaults:
#+begin_src emacs-lisp :tangle yes

(setq-default
 delete-by-moving-to-trash t                      ; Delete files to trash
 window-combination-resize t                      ; take new window space from all other windows (not just current)
 x-stretch-cursor t)                              ; Stretch cursor to the glyph width

(setq undo-limit 80000000                         ; Raise undo-limit to 80Mb
      evil-want-fine-undo t                       ; By default while in insert all changes are one big blob. Be more granular
      auto-save-default t                         ; Nobody likes to loose work, I certainly don't
      truncate-string-ellipsis "‚Ä¶"                ; Unicode ellispis are nicer than "...", and also save /precious/ space
      password-cache-expiry nil                   ; I can trust my computers ... can't I?
      ;; scroll-preserve-screen-position 'always     ; Don't have `point' jump around
      scroll-margin 2)                            ; It's nice to maintain a little margin

(display-time-mode 1)                             ; Enable time in the mode-line

(unless (string-match-p "^Power N/A" (battery))   ; On laptops...
  (display-battery-mode 1))                       ; it's nice to know how much power you have

(global-subword-mode 1)                           ; Iterate through CamelCase words

(setq-default
 ad-redefinition-action 'accept         ; Silence warnings for redefinition
 create-lockfiles nil                   ; Locks are more nuisance than blessing
 cursor-in-non-selected-windows nil     ; Hide the cursor in inactive windows
 cursor-type '(hbar . 2)                ; Underline-shaped cursor
 custom-unlispify-menu-entries nil      ; Prefer kebab-case for titles
 custom-unlispify-tag-names nil         ; Prefer kebab-case for symbols
 fill-column 80                         ; Set width for automatic line breaks
 gc-cons-threshold (* 8 1024 1024)      ; We're not using Game Boys anymore
 help-window-select t                   ; Focus new help windows when opened
 indent-tabs-mode nil                   ; Stop using tabs to indent
 inhibit-startup-screen t               ; Disable start-up screen
 initial-scratch-message ""             ; Empty the initial *scratch* buffer
 initial-major-mode #'org-mode          ; Prefer `org-mode' for *scratch*
 mouse-yank-at-point t                  ; Yank at point rather than pointer
 native-comp-async-report-warnings-errors 'silent ; Skip error buffers
 read-process-output-max (* 1024 1024)  ; Increase read size for data chunks
 recenter-positions '(5 bottom)         ; Set re-centering positions
 scroll-conservatively 101              ; Avoid recentering when scrolling far
 scroll-margin 1                        ; Add a margin when scrolling vertically
 select-enable-clipboard t              ; Merge system's and Emacs' clipboard
 sentence-end-double-space nil          ; Use a single space after dots
 show-help-function nil                 ; Disable help text everywhere
 tab-width 4                            ; Smaller width for tab characters
 uniquify-buffer-name-style 'forward    ; Uniquify buffer names
 use-short-answers t                    ; Replace yes/no prompts with y/n
 window-combination-resize t            ; Resize windows proportionally
 x-stretch-cursor t)                    ; Stretch cursor to the glyph width
(blink-cursor-mode 0)                   ; Prefer a still cursor
(delete-selection-mode 1)               ; Replace region when inserting text
(global-subword-mode 1)                 ; Iterate through CamelCase words
(mouse-avoidance-mode 'exile)           ; Avoid collision of mouse with point
(put 'downcase-region 'disabled nil)    ; Enable `downcase-region'
(put 'scroll-left 'disabled nil)        ; Enable `scroll-left'
(put 'upcase-region 'disabled nil)      ; Enable `upcase-region'
(set-default-coding-systems 'utf-8)     ; Default to utf-8 encoding
#+end_src

#+RESULTS:
: (utf-8-unix . utf-8-unix)

*** Auto-customizations
By default, changes made via a customisation interface are added to the init
file, so in order to better organise our files, let's create a specific file for this.
#+begin_src emacs-lisp :tangle yes
(setq-default custom-file (expand-file-name ".custom.el" doom-private-dir))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src

*** Windows
Let's customize some window behaviours, first let's enable both way window
vspliting.
#+begin_src emacs-lisp :tangle yes
(setq evil-vsplit-window-right t
      evil-split-window-below t)
#+end_src
Also show the list of buffers when splitting.
#+begin_src emacs-lisp :tangle yes
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (consult-buffer))
#+end_src

*** Frame sizing
Since it's quick to create new frames and maximise them, we'll want to be
conservative and fix the size of new frames inside the same emacs instance to be roughly 80% of the original.
#+begin_src emacs-lisp :tangle yes
(add-to-list 'default-frame-alist '(height . 24))
(add-to-list 'default-frame-alist '(width . 80))
#+end_src

*** Buffer defaults
I‚Äôd much rather have my new buffers in org-mode than fundamental-mode, hence
#+begin_src emacs-lisp :tangle yes
(setq-default major-mode 'org-mode)
#+end_src


** Doom configuration
*** Visual settings
Maybe I'll change the fonts after sometime, I tend to get sick of a certain design choice in my config after some time. But by now, we can live with that.
Why these specific fonts you ask? Well, citing tecosaur:
#+begin_quote
‚ÄôFira Code‚Äô is nice, and ‚ÄôOverpass‚Äô makes for a nice sans companion. We just need to fiddle with the font sizes a tad so that they visually match. Just for fun I‚Äôm trying out JetBrains Mono though. So far I have mixed feelings on it, some aspects are nice, but on others I prefer Fira.
#+end_quote

This is just a elegant manner to say that I simply got along with their mindset
without much thinking.
#+begin_src emacs-lisp
(setq doom-font (font-spec :family "FiraEmacs Regular" :size 24)
      doom-big-font (font-spec :family "FiraEmacs Regular" :size 36)
      doom-variable-pitch-font (font-spec :family "Overpass" :size 24)
      doom-unicode-font (font-spec :family "JuliaMono")
      doom-serif-font (font-spec :family "IBM Plex Mono" :weight 'light))
#+end_src

#+RESULTS:
: #<font-spec nil nil IBM\ Plex\ Mono nil nil light nil nil nil nil nil nil nil>

#+begin_src emacs-lisp :tangle yes
(use-package fira-code)
#+end_src

*** Theme and modeline
This part is probabibly the most instable on my config. I won't write anything
specific because it will change *a lot*.
#+begin_src emacs-lisp :tangle yes
(setq doom-theme 'doom-vibrant)
(remove-hook 'window-setup-hook #'doom-init-theme-h)
(add-hook 'after-init-hook #'doom-init-theme-h 'append)
(delq! t custom-theme-load-path)
#+end_src

I've changed the modeline color from red to orange so it won't be screaming on
my screen that I didn't save the file (remember that we have autosave turned
on).
#+begin_src emacs-lisp :tangle yes
(custom-set-faces!
  '(doom-modeline-buffer-modified :foreground "orange"))
#+end_src

We'll also conditionally hide the modeline file encoding because it's not worth
noting.
#+begin_src emacs-lisp :tangle yes
(defun doom-modeline-conditional-buffer-encoding ()
  "We expect the encoding to be LF UTF-8, so only show the modeline when this is not the case"
  (setq-local doom-modeline-buffer-encoding
              (unless (and (memq (plist-get (coding-system-plist buffer-file-coding-system) :category)
                                 '(coding-category-undecided coding-category-utf-8))
                           (not (memq (coding-system-eol-type buffer-file-coding-system) '(1 2))))
                t)))

(add-hook 'after-change-major-mode-hook #'doom-modeline-conditional-buffer-encoding)
#+end_src

*** Miscellaneous
Relative line numbers are fantastic for knowing how far away line numbers are.
#+begin_src emacs-lisp :tangle yes
(setq display-line-numbers-type 'relative)
#+end_src
Some nicer default buffer names.
#+begin_src emacs-lisp :tangle yes
(setq doom-fallback-buffer-name "‚ñ∫ Doom"
      +doom-dashboard-name "‚ñ∫ Doom")
#+end_src


*** Dashboard
We can take advantage of the dashboard being it's own major mode to set some
useful commands.

#+begin_src emacs-lisp :tangle yes
(defun +doom-dashboard-setup-modified-keymap ()
  (setq +doom-dashboard-mode-map (make-sparse-keymap))
  (map! :map +doom-dashboard-mode-map
        :desc "Find file" :ne "f" #'find-file
        :desc "Recent files" :ne "r" #'consult-recent-file
        :desc "Config dir" :ne "C" #'doom/open-private-config
        :desc "Open calc" :ne "+" #'calc
        :desc "Open config.org" :ne "c" (cmd! (find-file (expand-file-name "config.org" doom-private-dir)))
        :desc "Open dotfile" :ne "." (cmd! (doom-project-find-file "~/.config/"))
        :desc "Notes (roam)" :ne "n" #'org-roam-node-find
        :desc "Switch buffer" :ne "b" #'+vertico/switch-workspace-buffer
        :desc "Switch buffers (all)" :ne "B" #'consult-buffer
        :desc "IBuffer" :ne "i" #'ibuffer
        :desc "Previous buffer" :ne "p" #'previous-buffer
        :desc "Set theme" :ne "t" #'consult-theme
        :desc "Quit" :ne "Q" #'save-buffers-kill-terminal
        :desc "Show keybindings" :ne "h" (cmd! (which-key-show-keymap '+doom-dashboard-mode-map))))

(add-transient-hook! #'+doom-dashboard-mode (+doom-dashboard-setup-modified-keymap))
(add-transient-hook! #'+doom-dashboard-mode :append (+doom-dashboard-setup-modified-keymap))
(add-hook! 'doom-init-ui-hook :append (+doom-dashboard-setup-modified-keymap))
#+end_src

I recommend the reader to add their most used commands here.


We'll set the dashboard on the following keybinding.
#+begin_src emacs-lisp :tangle yes
(map! :leader :desc "Dashboard" "d" #'+doom-dashboard/open)
#+end_src

** Other things

*** Mouse buttons
Maybe you want to use the secondary mouse buttons instead of page-up/page-down.
#+begin_src emacs-lisp
(map! :n [mouse-8] #'better-jumper-jump-backward
      :n [mouse-9] #'better-jumper-jump-forward)
#+end_src

#+RESULTS:

*** Window title
Just the buffer and/or the project name is enough.
#+begin_src emacs-lisp
(setq frame-title-format
      '(""
        (:eval
         (if (s-contains-p org-roam-directory (or buffer-file-name ""))
             (replace-regexp-in-string
              ".*/[0-9]*-?" "‚ò∞ "
              (subst-char-in-string ?_ ?  buffer-file-name))
           "%b"))
        (:eval
         (let ((project-name (projectile-project-name)))
           (unless (string= "-" project-name)
             (format (if (buffer-modified-p)  " ‚óâ %s" " ‚ÄÜ‚óè‚ÄÜ %s") project-name))))))
#+end_src

#+RESULTS:
|   | (:eval (if (s-contains-p org-roam-directory (or buffer-file-name )) (replace-regexp-in-string .*/[0-9]*-? ‚ò∞  (subst-char-in-string 95 32 buffer-file-name)) %b)) | (:eval (let ((project-name (projectile-project-name))) (unless (string= - project-name) (format (if (buffer-modified-p)  ‚óâ %s  ‚ÄÜ‚óè‚ÄÜ %s) project-name)))) |

*** Splash screen

Maybe it's the physicist talking, but I think that a black hole drawing looks
super cool for a splash screen.

The following code makes it theme-appropriate and resizes it along the frame.
#+begin_src emacs-lisp :tangle yes
(defvar fancy-splash-image-template
  (expand-file-name "misc/emacs-e-template.svg" doom-private-dir)
  "Default template svg used for the splash image, with substitutions from ")

(setq fancy-splash-e-image (expand-file-name "misc/emacs-e-template.svg" doom-private-dir))
(setq fancy-splash-0-image fancy-splash-e-image)

(defvar fancy-splash-sizes
  `((:height 300 :min-height 50 :padding (0 . 2))
    (:height 250 :min-height 42 :padding (2 . 4))
    (:height 200 :min-height 35 :padding (3 . 3))
    (:height 150 :min-height 28 :padding (3 . 3))
    (:height 100 :min-height 20 :padding (2 . 2))
    (:height 75  :min-height 15 :padding (2 . 1))
    (:height 50  :min-height 10 :padding (1 . 0))
    (:height 1   :min-height 0  :padding (0 . 0)))
  "list of plists with the following properties
  :height the height of the image
  :min-height minimum `frame-height' for image
  :padding `+doom-dashboard-banner-padding' (top . bottom) to apply
  :template non-default template file
  :file file to use instead of template")


(defvar fancy-splash-template-colours
  '(("$colour1" . keywords) ("$colour2" . type) ("$colour3" . base5) ("$colour4" . base8))
  "list of colour-replacement alists of the form (\"$placeholder\" . 'theme-colour) which applied the template")

(unless (file-exists-p (expand-file-name "theme-splashes" doom-cache-dir))
  (make-directory (expand-file-name "theme-splashes" doom-cache-dir) t))

(defun fancy-splash-filename (theme-name height)
  (expand-file-name (concat (file-name-as-directory "theme-splashes")
                            (symbol-name doom-theme)
                            "-" (number-to-string height) ".svg")
                    doom-cache-dir))

(defun fancy-splash-clear-cache ()
  "Delete all cached fancy splash images"
  (interactive)
  (delete-directory (expand-file-name "theme-splashes" doom-cache-dir) t)
  (message "Cache cleared!"))

(defun fancy-splash-generate-image (template height)
  "Read TEMPLATE and create an image if HEIGHT with colour substitutions as  ;described by `fancy-splash-template-colours' for the current theme"
    (with-temp-buffer
      (insert-file-contents template)
      (re-search-forward "$height" nil t)
      (replace-match (number-to-string height) nil nil)
      (dolist (substitution fancy-splash-template-colours)
        (beginning-of-buffer)
        (while (re-search-forward (car substitution) nil t)
          (replace-match (doom-color (cdr substitution)) nil nil)))
      (write-region nil nil
                    (fancy-splash-filename (symbol-name doom-theme) height) nil nil)))

(defun fancy-splash-generate-images ()
  "Perform `fancy-splash-generate-image' in bulk"
  (dolist (size fancy-splash-sizes)
    (unless (plist-get size :file)
      (fancy-splash-generate-image (cond ((plist-get size :file) (plist-get size :file))
                                         ((plist-get size :template) (plist-get size :template))
                                         (fancy-splash-image-template fancy-splash-image-template))
                                   (plist-get size :height)))))

(defun ensure-theme-splash-images-exist (&optional height)
  (unless (file-exists-p (fancy-splash-filename
                          (symbol-name doom-theme)
                          (cond (height height)
                                ((plist-get (car fancy-splash-sizes) :height)
                                 (plist-get (car fancy-splash-sizes) :height)))))
    (fancy-splash-generate-images)))

(defun get-appropriate-splash ()
  (let ((height (frame-height)))
    (cl-some (lambda (size) (when (>= height (plist-get size :min-height)) size))
             fancy-splash-sizes)))

(setq fancy-splash-last-size nil)
(setq fancy-splash-last-theme nil)
(defun set-appropriate-splash (&optional frame)
  (let ((appropriate-image (get-appropriate-splash)))
    (unless (and (equal appropriate-image fancy-splash-last-size)
                 (equal doom-theme fancy-splash-last-theme)))
    (unless (plist-get appropriate-image :file)
      (ensure-theme-splash-images-exist (plist-get appropriate-image :height)))
    (setq fancy-splash-image
          (if (plist-get appropriate-image :file)
              (plist-get appropriate-image :file)
            (fancy-splash-filename (symbol-name doom-theme) (plist-get appropriate-image :height))))
    (setq +doom-dashboard-banner-padding (plist-get appropriate-image :padding))
    (setq fancy-splash-last-size appropriate-image)
    (setq fancy-splash-last-theme doom-theme)
    (+doom-dashboard-reload)))

(add-hook 'window-size-change-functions #'set-appropriate-splash)
(add-hook 'doom-load-theme-hook #'set-appropriate-splash)
#+end_src

Let's also add an interesting phrase/quote below the image.

#+begin_src emacs-lisp :tangle yes
(defvar splash-phrase-source-folder
  (expand-file-name "misc/splash-phrases" doom-private-dir)
  "A folder of text files with a fun phrase on each line.")

(defvar splash-phrase-sources
  (let* ((files (directory-files splash-phrase-source-folder nil "\\.txt\\'"))
         (sets (delete-dups (mapcar
                             (lambda (file)
                               (replace-regexp-in-string "\\(?:-[0-9]+-\\w+\\)?\\.txt" "" file))
                             files))))
    (mapcar (lambda (sset)
              (cons sset
                    (delq nil (mapcar
                               (lambda (file)
                                 (when (string-match-p (regexp-quote sset) file)
                                   file))
                               files))))
            sets))
  "A list of cons giving the phrase set name, and a list of files which contain phrase components.")

(defvar splash-phrase-set
  (nth (random (length splash-phrase-sources)) (mapcar #'car splash-phrase-sources))
  "The default phrase set. See `splash-phrase-sources'.")

(defun splase-phrase-set-random-set ()
  "Set a new random splash phrase set."
  (interactive)
  (setq splash-phrase-set
        (nth (random (1- (length splash-phrase-sources)))
             (cl-set-difference (mapcar #'car splash-phrase-sources) (list splash-phrase-set))))
  (+doom-dashboard-reload t))

(defvar splase-phrase--cache nil)

(defun splash-phrase-get-from-file (file)
  "Fetch a random line from FILE."
  (let ((lines (or (cdr (assoc file splase-phrase--cache))
                   (cdar (push (cons file
                                     (with-temp-buffer
                                       (insert-file-contents (expand-file-name file splash-phrase-source-folder))
                                       (split-string (string-trim (buffer-string)) "\n")))
                               splase-phrase--cache)))))
    (nth (random (length lines)) lines)))

(defun splash-phrase (&optional set)
  "Construct a splash phrase from SET. See `splash-phrase-sources'."
  (mapconcat
   #'splash-phrase-get-from-file
   (cdr (assoc (or set splash-phrase-set) splash-phrase-sources))
   " "))

(defun doom-dashboard-phrase ()
  "Get a splash phrase, flow it over multiple lines as needed, and make fontify it."
  (mapconcat
   (lambda (line)
     (+doom-dashboard--center
      +doom-dashboard--width
      (with-temp-buffer
        (insert-text-button
         line
         'action
         (lambda (_) (+doom-dashboard-reload t))
         'face 'doom-dashboard-menu-title
         'mouse-face 'doom-dashboard-menu-title
         'help-echo "Random phrase"
         'follow-link t)
        (buffer-string))))
   (split-string
    (with-temp-buffer
      (insert (splash-phrase))
      (setq fill-column (min 70 (/ (* 2 (window-width)) 3)))
      (fill-region (point-min) (point-max))
      (buffer-string))
    "\n")
   "\n"))

(defadvice! doom-dashboard-widget-loaded-with-phrase ()
  :override #'doom-dashboard-widget-loaded
  (setq line-spacing 0.2)
  (insert
   "\n\n"
   (propertize
    (+doom-dashboard--center
     +doom-dashboard--width
     (doom-display-benchmark-h 'return))
    'face 'doom-dashboard-loaded)
   "\n"
   (doom-dashboard-phrase)
   "\n"))
#+end_src

Let's also remove the dashboard standard commands to get a cleaner look.

#+begin_src emacs-lisp :tangle yes
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu)
(add-hook! '+doom-dashboard-mode-hook (hide-mode-line-mode 1) (hl-line-mode -1))
(setq-hook! '+doom-dashboard-mode-hook evil-normal-state-cursor (list nil))
#+end_src

* Packages

*An important disclaimer:* For now, here is only the configuration file for the
~config.el~. For installing packages, you'll need to set-up the package installation
on ~package.el~.
I also highly recommend you to read through the documentation of the packages listed here, to know their importance and to modify them to better fit your need.
** Abbrev
According to a list of misspelled words, the abbrev built-in package automatically corrects these words on the fly.

#+begin_src emacs-lisp :tangle yes
(use-package abbrev
  :ensure nil
  :hook (org-mode . abbrev-mode)
  :custom (abbrev-file-name (expand-file-name (format "%s/emacs/abbrev_defs" xdg-data)))
  :config
  (if (file-exists-p abbrev-file-name)
      (quietly-read-abbrev-file)))
#+end_src
** Fly Spell
I use the flyspell built-in package to enable spell checking on-the-fly in GNU Emacs. A useful flyspell command is flyspell-auto-correct-word (M-TAB) which automatically corrects a word according to the best suggestion.

#+begin_src emacs-lisp :tangle yes
(use-package flyspell
  :ensure nil
  :delight
  :hook ((text-mode . flyspell-mode)
         (prog-mode . flyspell-prog-mode))
  :custom
  ;; Add correction to abbreviation table.
  (flyspell-abbrev-p t)
  (flyspell-default-dictionary "en_US")
  (flyspell-issue-message-flag nil)
  (flyspell-issue-welcome-flag nil))
#+end_src
** Ispell
To correct spelling mistakes, the ispell built-in package use a spell checker package (e.g., hunspell or aspell). The aspell spell checker package would make it easier to spot errors in camelCase, which can be handy when programming. However, I personally use hunspell which only checks the spelling of comments in the code and because it is more consistent on fly spells than aspell.

To use hunspell you need to install it with your system package manager, as well as install the desired language dictionaries (e.g., hunspell-en_US and hunspell-fr).

Finally, you can check that you have installed the language dictionaries by using the hunspell -D command.
#+begin_src emacs-lisp :tangle yes
(use-package ispell
  :preface
  (defun my/switch-language ()
    "Switch between the English and Portuguese for ispell, flyspell, and LanguageTool."
    (interactive)
    (let* ((current-dictionary ispell-current-dictionary)
           (new-dictionary (if (string= current-dictionary "en_US") "pt_BR" "en_US")))
      (ispell-change-dictionary new-dictionary)
      (if (string= new-dictionary "pt_BR")
          (progn
            (setq lsp-ltex-language "pt"))
        (progn
          (setq lsp-ltex-language "en-US")))
      (flyspell-buffer)
      (message "[‚úì] Dictionary switched to %s" new-dictionary)))
  :custom
  (ispell-hunspell-dict-paths-alist
   '(("en_US" "/usr/share/hunspell/en_US.aff")
     ("pt_BR" "/usr/share/hunspell/pt_BR.aff")))
  ;; Save words in the personal dictionary without asking.
  (ispell-silently-savep t)
  :config
  (setenv "LANG" "en_US")
  (cond ((executable-find "hunspell")
         (setq ispell-program-name "hunspell")
         (setq ispell-local-dictionary-alist '(("en_US"
                                                "[[:alpha:]]"
                                                "[^[:alpha:]]"
                                                "['‚Äô-]"
                                                t
                                                ("-d" "en_US" )
                                                nil
                                                utf-8)
                                               ("pt_BR"
                                                "[[:alpha:]√Ä√Ç√á√à√â√ä√ã√é√è√î√ô√õ√ú√†√¢√ß√®√©√™√´√Æ√Ø√¥√π√ª√º]"
                                                "[^[:alpha:]√Ä√Ç√á√à√â√ä√ã√é√è√î√ô√õ√ú√†√¢√ß√®√©√™√´√Æ√Ø√¥√π√ª√º]"
                                                "['‚Äô-]"
                                                t
                                                ("-d" "pt_BR")
                                                nil
                                                utf-8))))
        ((executable-find "aspell")
         (setq ispell-program-name "aspell")
         (setq ispell-extra-args '("--sug-mode=ultra"))))
  ;; Ignore file sections for spell checking.
  (add-to-list 'ispell-skip-region-alist '("#\\+begin_align" . "#\\+end_align"))
  (add-to-list 'ispell-skip-region-alist '("#\\+begin_align*" . "#\\+end_align*"))
  (add-to-list 'ispell-skip-region-alist '("#\\+begin_equation" . "#\\+end_equation"))
  (add-to-list 'ispell-skip-region-alist '("#\\+begin_equation*" . "#\\+end_equation*"))
  (add-to-list 'ispell-skip-region-alist '("#\\+begin_example" . "#\\+end_example"))
  (add-to-list 'ispell-skip-region-alist '("#\\+begin_labeling" . "#\\+end_labeling"))
  (add-to-list 'ispell-skip-region-alist '("#\\+begin_src" . "#\\+end_src"))
  (add-to-list 'ispell-skip-region-alist '("\\$" . "\\$"))
  (add-to-list 'ispell-skip-region-alist '(org-property-drawer-re))
  (add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:")))

#+end_src
** LanguageTool
LanguageTool is great for correcting your grammar while you are writing or saving your buffer. Combined with abbrev-mode and flyspell, you will have better quality documents. To use LanguageTool with LSP mode, the lsp-ltex package is what you need. The first time you use it, it will download the LTEX Language Server LSP server for you.
#+begin_src emacs-lisp :tangle yes
(use-package lsp-ltex
  :ensure t
  :init
  (setq lsp-ltex-version "15.2.0"))  ; make sure you have set this, see below
  #+end_src

#+RESULTS:
| er/add-text-mode-expansions | (lambda nil (require 'lsp-ltex) (lsp)) | flyspell-mode | visual-line-mode | display-line-numbers-mode | vi-tilde-fringe-mode | text-mode-hook-identify |


** Avy
Avy is a package that helps to move faster through the document (and even through different buffers).
#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-;") 'avy-goto-char)
(setq avy-case-fold-search nil)       ;; case sensitive makes selection easier
(bind-key "C-:"    'avy-goto-char-2)  ;; I use this most frequently
(bind-key "C-'"    'avy-goto-line)    ;; Consistent with ivy-avy
(bind-key "M-g c"  'avy-goto-char)
(bind-key "M-g e"  'avy-goto-word-0)  ;; lots of candidates
(bind-key "M-g g"  'avy-goto-line)    ;; digits behave like goto-line
(bind-key "M-g w"  'avy-goto-word-1)  ;; first character of the word
(bind-key "M-g ("  'avy-goto-open-paren)
(bind-key "M-g )"  'avy-goto-close-paren)
(bind-key "M-g P"  'avy-pop-mark)
#+end_src
** Visual undo
Something that's being bothering me for a long time is the absence of a tree
undo. Thankfully we have a package just for that.

#+begin_src emacs-lisp :tangle yes
(use-package! vundo
  :commands (vundo)
  :defer t
  :init
  (defconst +vundo-unicode-symbols
   '((selected-node   . ?‚óè)
     (node            . ?‚óã)
     (vertical-stem   . ?‚îÇ)
     (branch          . ?‚îú)
     (last-branch     . ?‚ï∞)
    (horizontal-stem . ?‚îÄ)))

  (map! :leader
        (:prefix ("o")
         :desc "vundo" "v" #'vundo))

  :config
  (setq vundo-glyph-alist +vundo-unicode-symbols
        vundo-compact-display t
        vundo-window-max-height 6)

  ;; Better contrasting highlight.
  (custom-set-faces
    '(vundo-node ((t (:foreground "#808080"))))
    '(vundo-stem ((t (:foreground "#808080"))))
    '(vundo-highlight ((t (:foreground "#FFFF00")))))

  ;; Use `HJKL` VIM-like motion, also Home/End to jump around.
  (define-key vundo-mode-map (kbd "l") #'vundo-forward)
  (define-key vundo-mode-map (kbd "<right>") #'vundo-forward)
  (define-key vundo-mode-map (kbd "h") #'vundo-backward)
  (define-key vundo-mode-map (kbd "<left>") #'vundo-backward)
  (define-key vundo-mode-map (kbd "j") #'vundo-next)
  (define-key vundo-mode-map (kbd "<down>") #'vundo-next)
  (define-key vundo-mode-map (kbd "k") #'vundo-previous)
  (define-key vundo-mode-map (kbd "<up>") #'vundo-previous)
  (define-key vundo-mode-map (kbd "<home>") #'vundo-stem-root)
  (define-key vundo-mode-map (kbd "<end>") #'vundo-stem-end)
  (define-key vundo-mode-map (kbd "q") #'vundo-quit)
  (define-key vundo-mode-map (kbd "C-g") #'vundo-quit)
  (define-key vundo-mode-map (kbd "RET") #'vundo-confirm))

(with-eval-after-load 'evil (evil-define-key 'normal 'global (kbd "C-M-u") 'vundo))

#+end_src

#+RESULTS:

** Which key
Let's make the popup a little faster.
#+begin_src emacs-lisp :tangle yes
(setq which-key-idle-delay 0.5) ;; I need the help, I really do
#+end_src

** Fontaine
This is a package to ease the font configuration, but it can be done without it.

#+begin_src emacs-lisp :tangle yes
(setq fontaine-presets
      '((tiny
         :default-family "Iosevka Comfy Wide Fixed"
         :default-height 70)
        (small
         :default-family "Iosevka Comfy Fixed"
         :default-height 90)
        (regular
         :default-height 100)
        (medium
         :default-height 110)
        (large
         :default-weight semilight
         :default-height 140
         :bold-weight extrabold)
        (presentation
         :default-weight semilight
         :default-height 170
         :bold-weight extrabold)
        (t
         ;; I keep all properties for didactic purposes, but most can be
         ;; omitted.  See the fontaine manual for the technicalities:
         ;; <https://protesilaos.com/emacs/fontaine>.
         :default-family "Iosevka Comfy"
         :default-weight regular
         :default-height 100
         :fixed-pitch-family nil ; falls back to :default-family
         :fixed-pitch-weight nil ; falls back to :default-weight
         :fixed-pitch-height 1.0
         :variable-pitch-family "Iosevka Comfy Duo"
         :variable-pitch-weight nil
         :variable-pitch-height 1.0
         :bold-family nil ; use whatever the underlying face has
         :bold-weight bold
         :italic-family nil
         :italic-slant italic
         :line-spacing nil)))
#+end_src

** Cursory
Same as above, just that now it's about cursors.

#+begin_src emacs-lisp :tangle yes
(setq cursory-presets
      '((bar
         :cursor-type (bar . 2)
         :cursor-in-non-selected-windows hollow
         :blink-cursor-blinks 10
         :blink-cursor-interval 0.5
         :blink-cursor-delay 0.2)
        (box
         :cursor-type box
         :cursor-in-non-selected-windows hollow
         :blink-cursor-blinks 10
         :blink-cursor-interval 0.5
         :blink-cursor-delay 0.2)
        (underscore
         :cursor-type (hbar . 3)
         :cursor-in-non-selected-windows hollow
         :blink-cursor-blinks 50
         :blink-cursor-interval 0.2
         :blink-cursor-delay 0.2)))
#+end_src

** Deft

#+begin_src emacs-lisp :tangle yes
(setq deft-directory "~/org")
(setq deft-recursive t)
(setq deft-extension "org")
(setq deft-text-mode 'org-mode)
(setq deft-use-filename-as-title t)
(setq deft-auto-save-interval 0)
#+end_src
** Beacon
Beacon highlights the current cursor line after major movements.
#+begin_src emacs-lisp :tangle yes
;; global beacon minor-mode
 (use-package! beacon)
 (after! beacon (beacon-mode 1))
#+end_src
** Divish
Dirvish offers a suitable replacement/enhancement for dired with features such as improved UI and image preview.
We just need to enable it.
#+begin_src emacs-lisp :tangle yes
(use-package! dirvish)
#+end_src
** Info colours
This makes manual pages nicer to look at by adding variable pitch fontification and colouring üôÇ.

#+begin_src emacs-lisp :tangle yes
(use-package! info-colors
  :commands (info-colors-fontify-node))

(add-hook 'Info-selection-hook 'info-colors-fontify-node)
#+end_src

* Languages

** Org
*** General Configuration
Let's set our org directory.
#+begin_src emacs-lisp :tangle yes
(setq org-directory "~/org")
#+end_src

Count all checkboxes, not just the ones directly below
#+begin_src emacs-lisp :tangle yes
(setq org-checkbox-hierarchical-statistics nil)
#+end_src

There are three ‚Äúmain‚Äù keywords and a ~WAITING~, ~HOLD~ and ~CANCELLED~ keyword that each require a note for justifying moving to these states.

#+begin_src emacs-lisp :tangle yes
(setq org-todo-keywords
    (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
            (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)"))))
#+end_src

This is so I cannot set a headline to DONE if children aren‚Äôt DONE.
#+begin_src emacs-lisp :tangle yes
(setq-default org-enforce-todo-dependencies t)
#+end_src

This sets the color of  the keywords

#+begin_src emacs-lisp :tangle yes
(setq org-todo-keyword-faces
    (quote (("TODO" :foreground "red" :weight bold)
            ("NEXT" :foreground "blue" :weight bold)
            ("DONE" :foreground "forest green" :weight bold)
            ("WAITING" :foreground "orange" :weight bold)
            ("HOLD" :foreground "magenta" :weight bold)
            ("CANCELLED" :foreground "forest green" :weight bold)
            ("MEETING" :foreground "forest green" :weight bold)
            ("PHONE" :foreground "forest green" :weight bold))))
;; I don't wan't the keywords in my exports by default
(setq-default org-export-with-todo-keywords nil)
#+end_src
Adding CDlatex-mode to org because it'll simplify my whole life!
#+begin_src emacs-lisp :tangle yes
(add-hook 'org-mode 'org-cdlatex-mode)
#+end_src

Also edit source code in the same window as the org file
#+begin_src emacs-lisp :tangle yes
(setq org-src-window-setup 'current-window)
#+end_src
*** Visuals
**** Font display
Mixed pitch is great. As is +org-pretty-mode, let‚Äôs use them.

#+begin_src emacs-lisp :tangle yes
(add-hook 'org-mode-hook #'+org-pretty-mode)
#+end_src

Let's make headings a bit bigger
#+begin_src emacs-lisp :tangle yes
(custom-set-faces!
  '(outline-1 :weight extra-bold :height 1.25)
  '(outline-2 :weight bold :height 1.15)
  '(outline-3 :weight bold :height 1.12)
  '(outline-4 :weight semi-bold :height 1.09)
  '(outline-5 :weight semi-bold :height 1.06)
  '(outline-6 :weight semi-bold :height 1.03)
  '(outline-8 :weight semi-bold)
  '(outline-9 :weight semi-bold))
#+end_src

And the same with the title
#+begin_src emacs-lisp :tangle yes
(custom-set-faces!
  '(org-document-title :height 1.2))
#+end_src

Also change the error face in deadlines
#+begin_src emacs-lisp :tangle yes
(setq org-agenda-deadline-faces
      '((1.001 . error)
        (1.0 . org-warning)
        (0.5 . org-upcoming-deadline)
        (0.0 . org-upcoming-distant-deadline)))
#+end_src

We can then have quote blocks stand out a bit more by making them italic.
#+begin_src emacs-lisp :tangle yes
(setq org-fontify-quote-and-verse-blocks t)
#+end_src


lets make latex-previews in org mdoe a bit bigger
#+begin_src emacs-lisp :tangle yes
(after! org (plist-put org-format-latex-options :scale 1.75))
#+end_src

**** Fontifying inline src blocks
Turning off Doom theme's extra fontification.
#+begin_src emacs-lisp :tangle yes
(setq doom-themes-org-fontify-special-tags nil)
#+end_src

**** Symbols
Let's change the default symbols used for headers (only if you like it, in my case we'll disable it later).
#+begin_src emacs-lisp :tangle yes
(after! org-superstar
  (setq org-superstar-headline-bullets-list '("‚óâ" "‚óã" "‚ú∏" "‚úø" "‚ú§" "‚úú" "‚óÜ" "‚ñ∂")
        org-superstar-prettify-item-bullets t ))

(setq org-ellipsis " ‚ñæ "
      org-hide-leading-stars t
      org-priority-highest ?A
      org-priority-lowest ?E
      org-priority-faces
      '((?A . 'all-the-icons-red)
        (?B . 'all-the-icons-orange)
        (?C . 'all-the-icons-yellow)
        (?D . 'all-the-icons-green)
        (?E . 'all-the-icons-blue)))
#+end_src

Some unicode symbols for org stuff
#+begin_src emacs-lisp :tangle yes
(appendq! +ligatures-extra-symbols
          `(:checkbox      "‚òê"
            :pending       "‚óº"
            :checkedbox    "‚òë"
            :list_property "‚à∑"
            :em_dash       "‚Äî"
            :ellipses      "‚Ä¶"
            :arrow_right   "‚Üí"
            :arrow_left    "‚Üê"
            :title         "ùôè"
            :subtitle      "ùô©"
            :author        "ùòº"
            :date          "ùòø"
            :property      "‚ò∏"
            :options       "‚å•"
            :startup       "‚èª"
            :macro         "ùìú"
            :html_head     "üÖ∑"
            :html          "üÖó"
            :latex_class   "üÑª"
            :latex_header  "üÖª"
            :beamer_header "üÖë"
            :latex         "üÖõ"
            :attr_latex    "üÑõ"
            :attr_html     "üÑó"
            :attr_org      "‚í™"
            :begin_quote   "‚ùù"
            :end_quote     "‚ùû"
            :caption       "‚ò∞"
            :header        "‚Ä∫"
            :results       "ü†∂"
            :begin_export  "‚è©"
            :end_export    "‚è™"
            :properties    "‚öô"
            :end           "‚àé"
            :priority_a   ,(propertize "‚öë" 'face 'all-the-icons-red)
            :priority_b   ,(propertize "‚¨Ü" 'face 'all-the-icons-orange)
            :priority_c   ,(propertize "‚ñ†" 'face 'all-the-icons-yellow)
            :priority_d   ,(propertize "‚¨á" 'face 'all-the-icons-green)
            :priority_e   ,(propertize "‚ùì" 'face 'all-the-icons-blue)))
(set-ligatures! 'org-mode
  :merge t
  :checkbox      "[ ]"
  :pending       "[-]"
  :checkedbox    "[X]"
  :list_property "::"
  :em_dash       "---"
  :ellipsis      "..."
  :arrow_right   "->"
  :arrow_left    "<-"
  :title         "#+title:"
  :subtitle      "#+subtitle:"
  :author        "#+author:"
  :date          "#+date:"
  :property      "#+property:"
  :options       "#+options:"
  :startup       "#+startup:"
  :macro         "#+macro:"
  :html_head     "#+html_head:"
  :html          "#+html:"
  :latex_class   "#+latex_class:"
  :latex_header  "#+latex_header:"
  :beamer_header "#+beamer_header:"
  :latex         "#+latex:"
  :attr_latex    "#+attr_latex:"
  :attr_html     "#+attr_html:"
  :attr_org      "#+attr_org:"
  :begin_quote   "#+begin_quote"
  :end_quote     "#+end_quote"
  :caption       "#+caption:"
  :header        "#+header:"
  :begin_export  "#+begin_export"
  :end_export    "#+end_export"
  :results       "#+RESULTS:"
  :property      ":PROPERTIES:"
  :end           ":END:"
  :priority_a    "[#A]"
  :priority_b    "[#B]"
  :priority_c    "[#C]"
  :priority_d    "[#D]"
  :priority_e    "[#E]")
(plist-put +ligatures-extra-symbols :name "‚Åç")
#+end_src

And we're using this package to prettify the tags
#+begin_src emacs-lisp :tangle yes
(use-package org-pretty-tags
:config
 (setq org-pretty-tags-surrogate-strings
       `(("uni"        . ,(all-the-icons-faicon   "graduation-cap" :face 'all-the-icons-purple  :v-adjust 0.01))
         ("linux"        . ,(all-the-icons-material "computer"       :face 'all-the-icons-silver  :v-adjust 0.01))
         ("tarefa" . ,(all-the-icons-material "library_books"  :face 'all-the-icons-orange  :v-adjust 0.01))
         ("prova"       . ,(all-the-icons-material "timer"          :face 'all-the-icons-red     :v-adjust 0.01))
         ("pessoal"    . ,(all-the-icons-fileicon "keynote"        :face 'all-the-icons-orange  :v-adjust 0.01))
         ("email"      . ,(all-the-icons-faicon   "envelope"       :face 'all-the-icons-blue    :v-adjust 0.01))
         ("ler"       . ,(all-the-icons-octicon  "book"           :face 'all-the-icons-lblue   :v-adjust 0.01))
         ("artigo"    . ,(all-the-icons-octicon  "file-text"      :face 'all-the-icons-yellow  :v-adjust 0.01))
         ("internet"        . ,(all-the-icons-faicon   "globe"          :face 'all-the-icons-green   :v-adjust 0.01))
         ("info"       . ,(all-the-icons-faicon   "info-circle"    :face 'all-the-icons-blue    :v-adjust 0.01))
         ("bug"      . ,(all-the-icons-faicon   "bug"            :face 'all-the-icons-red     :v-adjust 0.01))
         ("algum dia"    . ,(all-the-icons-faicon   "calendar-o"     :face 'all-the-icons-cyan    :v-adjust 0.01))
         ("idea"       . ,(all-the-icons-octicon  "light-bulb"     :face 'all-the-icons-yellow  :v-adjust 0.01))
         ("emacs"      . ,(all-the-icons-fileicon "emacs"          :face 'all-the-icons-lpurple :v-adjust 0.01))
         ("emacs"      . ,(all-the-icons-fileicon "emacs"          :face 'all-the-icons-lpurple :v-adjust 0.01))))

 (org-pretty-tags-global-mode))
#+end_src

Let's allow org mode to show latex entities as UTF-8 characters
#+begin_src emacs-lisp :tangle yes
(setq org-pretty-entities t)
#+end_src

Increase indentation in org-indent
#+begin_src emacs-lisp :tangle yes
(setq org-indent-indentation-per-level 6)
(setq org-indent-boundary-char ?„ÄÄ)
#+end_src

For aesthetic purposes, let's change the TODO keywords to symbols.

*** Exports
**** LaTeX
***** LaTeX export template setup
Let's setup our latex export from org files in order to produce documents with a certain template (I hate LaTeX standard template).

#+begin_src emacs-lisp :tangle yes
(with-eval-after-load 'ox-latex
(add-to-list 'org-latex-classes
             '("org-plain-latex"
               "\\documentclass{article}
           [NO-DEFAULT-PACKAGES]
           [PACKAGES]
           [EXTRA]"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))

#+end_src

The template file is on the ~~/org/annotations/templates/~ folder.
***** Compiling
By default, Org uses pdflatex + bibtex. This simply won‚Äôt do in our modern world. latexmk + biber (which is used automatically with latexmk) is a simply superior

#+begin_src emacs-lisp :tangle yes
;; org-latex-compilers = ("pdflatex" "xelatex" "lualatex"), which are the possible values for %latex
(setq org-latex-pdf-process '("LC_ALL=en_US.UTF-8 latexmk -f -pdf -%latex -shell-escape -interaction=nonstopmode -output-directory=%o %f"))
#+end_src

**** Jupyter
Let's add the option to export as a jupyter notebook.
#+begin_src emacs-lisp :tangle yes
(require 'ox-ipynb)
#+end_src

*** Packages
**** Agenda
Enable the compact layout on agenda
#+begin_src emacs-lisp :tangle yes
(setq org-agenda-compact-blocks t)
#+end_src

Restore layout after agenda view
#+begin_src emacs-lisp :tangle yes
(setq org-agenda-restore-windows-after-quit t)
#+end_src

Set the default appointment duration to be 60 min.
#+begin_src emacs-lisp :tangle yes
(setq org-agenda-default-appointment-duration 60)
#+end_src

Include these files on the agenda.
#+begin_src emacs-lisp :tangle yes
(setq org-agenda-files '("~/org/agenda"))
#+end_src

Don't show tasks in agenda if they are done
#+begin_src emacs-lisp :tangle yes
(setq org-agenda-skip-deadline-if-done t)
(setq org-agenda-skip-scheduled-if-done t)
#+end_src

Warn about a deadline
#+begin_src emacs-lisp :tangle yes
(setq org-deadline-warning-days 90)
#+end_src

Agenda starts on the current day
#+begin_src emacs-lisp :tangle yes
(setq org-agenda-start-on-weekday nil)
#+end_src

Display format and sorting strategy
#+begin_src emacs-lisp :tangle yes
(setq org-agenda-prefix-format
      (quote
       ((agenda . "%s %?-12t %e ")
        (timeline . "  %s")
        (todo . " %i %e ")
        (tags . " %i %e ")
        (search . " %i %e "))))

(setq org-agenda-sorting-strategy
      (quote
       ((agenda priority-down alpha-up)
        (todo priority-down alpha-up)
        (tags priority-down alpha-up))))
#+end_src


**** TODO Org-caldav
*DISCLAIMER:* not working.

Org cal-dav is a package used for synchronizing org-agenda with other external calendars.
This config has been  taken from a reddit post (see it [[https://www.reddit.com/r/orgmode/comments/8rl8ep/making_orgcaldav_useable/][here]]).
The whole process of configuring org-caldav is long and boring and it requires external tools in order to work, you can see it on the package [[https://github.com/dengste/org-caldav][page]] on github.

#+begin_src emacs-lisp :tangle yes
;; (use-package org-caldav
;;   :init
;;   ;; This is the sync on close function; it also prompts for save after syncing so
;;   ;; no late changes get lost
;;   (defun org-caldav-sync-at-close ()
;;     (org-caldav-sync)
;;     (save-some-buffers))

;;   ;; This is the delayed sync function; it waits until emacs has been idle for
;;   ;; "secs" seconds before syncing.  The delay is important because the caldav-sync
;;   ;; can take five or ten seconds, which would be painful if it did that right at save.
;;   ;; This way it just waits until you've been idle for a while to avoid disturbing
;;   ;; the user.
;;   (defvar org-caldav-sync-timer nil
;;      "Timer that `org-caldav-push-timer' used to reschedule itself, or nil.")
;;   (defun org-caldav-sync-with-delay (secs)
;;     (when org-caldav-sync-timer
;;       (cancel-timer org-caldav-sync-timer))
;;     (setq org-caldav-sync-timer
;; 	  (run-with-idle-timer
;; 	   (* 1 secs) nil 'org-caldav-sync)))

;;   ;; Actual calendar configuration edit this to meet your specific needs
;;   (setq org-caldav-url "put_your_caldav_url_here")
;;       (setq org-caldav-calendars
;;     '((:calendar-id "desk-org"
;; 	    	:files ("~/path-to-file.org" "~/path-to-file-2.org")
;; 		:inbox "~/Calendars/org-caldav-inbox.org")
;; 	  (:calendar-id "shared_cal1"
;; 		:files ("~/Calendars/shared_cal1.org")
;; 		:inbox "~/Calendars/shared_cal1.org")
;;       (:calendar-id "default"
;;        :files ("~/Calendars/shared_cal2.org")
;;        :inbox "~/Calendars/shared_cal2.org")))
;;   (setq org-caldav-backup-file "~/org-caldav/org-caldav-backup.org")
;;   (setq org-caldav-save-directory "~/org-caldav/")

;;   :config
;;   (setq org-icalendar-alarm-time 1)
;;   ;; This makes sure to-do items as a category can show up on the calendar
;;   (setq org-icalendar-include-todo t)
;;   ;; This ensures all org "deadlines" show up, and show up as due dates
;;   (setq org-icalendar-use-deadline '(event-if-todo event-if-not-todo todo-due))
;;   ;; This ensures "scheduled" org items show up, and show up as start times
;;   (setq org-icalendar-use-scheduled '(todo-start event-if-todo event-if-not-todo))
;;   ;; Add the delayed save hook with a five minute idle timer
;;   (add-hook 'after-save-hook
;; 	    (lambda ()
;; 	      (when (eq major-mode 'org-mode)
;; 		(org-caldav-sync-with-delay 300))))
;;   ;; Add the close emacs hook
;;   (add-hook 'kill-emacs-hook 'org-caldav-sync-at-close))
#+end_src

**** Super agenda
Org agenda is great, but a souped version is even better.
#+begin_src emacs-lisp :tangle yes

(use-package! org-super-agenda
  :commands org-super-agenda-mode)

(after! org-agenda
  (org-super-agenda-mode))

(setq org-agenda-skip-scheduled-if-done t
      org-agenda-skip-deadline-if-done t
      org-agenda-include-deadlines t
      org-agenda-block-separator nil
      org-agenda-tags-column 100 ;; from testing this seems to be a good value
      org-agenda-compact-blocks t)

(setq org-agenda-custom-commands
      '(("o" "Overview"
         ((agenda "" ((org-agenda-span 'day)
                      (org-super-agenda-groups
                       '((:name "Today"
                          :time-grid t
                          :date today
                          :todo "TODAY"
                          :scheduled today
                          :order 1)))))
          (alltodo "" ((org-agenda-overriding-header "")
                       (org-super-agenda-groups
                        '((:name "Next to do"
                           :todo "NEXT"
                           :order 1)
                          (:name "Important"
                           :tag "Important"
                           :priority "A"
                           :order 6)
                          (:name "Due Today"
                           :deadline today
                           :order 2)
                          (:name "Due Soon"
                           :deadline future
                           :order 8)
                          (:name "Overdue"
                           :deadline past
                           :face error
                           :order 7)
                          (:name "Assignments"
                           :tag "Assignment"
                           :order 10)
                          (:name "Issues"
                           :tag "Issue"
                           :order 12)
                          (:name "Emacs"
                           :tag "Emacs"
                           :order 13)
                          (:name "Projects"
                           :tag "Project"
                           :order 14)
                          (:name "Research"
                           :tag "Research"
                           :order 15)
                          (:name "To read"
                           :tag "Read"
                           :order 30)
                          (:name "Waiting"
                           :todo "WAITING"
                           :order 20)
                          (:name "University"
                           :tag "uni"
                           :order 32)
                          (:name "Trivial"
                           :priority<= "E"
                           :tag ("Trivial" "Unimportant")
                           :todo ("SOMEDAY" )
                           :order 90)
                          (:discard (:tag ("Chore" "Routine" "Daily")))))))))))
                          #+end_src

**** Org-roam
Let's set the org roam directory

#+begin_src emacs-lisp :tangle yes
(setq org-roam-directory "~/org/annotations/root/")
#+end_src

**** Org-special-block-extras

#+begin_src emacs-lisp :tangle yes
(use-package org-special-block-extras
  :ensure t
  :hook (org-mode . org-special-block-extras-mode))
#+end_src

**** GTD
We'll setup our org mode agenda following the principles on [[https://lucidmanager.org/productivity/getting-things-done-with-emacs/][Getting Things Done]]. We'll use a package called org-gtd to do the dirty work for us üòé .
We are using the settings given by the package maintainer.
#+begin_src emacs-lisp :tangle yes
(use-package org-gtd
  :after org
  :demand t
  :custom
  (org-gtd-directory "~/org/agenda")
  (org-edna-use-inheritance t)
  :config
  (org-edna-mode)
  :bind
  (("C-c d c" . org-gtd-capture)
   ("C-c d e" . org-gtd-engage)
   ("C-c d p" . org-gtd-process-inbox)
   ("C-c d n" . org-gtd-show-all-next)
   ("C-c d s" . org-gtd-show-stuck-projects)
   :map org-gtd-process-map
   ("C-c c" . org-gtd-choose)))
 #+end_src

 In order for the package to work, we'll set org edna to change the next TODO item to NEXT in a project.
 #+begin_src emacs-lisp :tangle yes
(setq org-edna-use-inheritance t)
(org-edna-mode 1)
 #+end_src

 Let's set the keybinding for processing the inbox smoother.
 #+begin_src emacs-lisp :tangle yes
(define-key org-gtd-process-map (kbd "C-c c") #'org-gtd-choose)
#+end_src

**** Org-modern

This package implements a ‚Äúmodern‚Äù style for your Org buffers using font locking and text properties.
#+begin_src emacs-lisp :tangle yes
(use-package! org-modern
  :hook (org-mode . org-modern-mode)
  :config
  (setq org-modern-star '("‚óâ" "‚óã" "‚ú∏" "‚úø" "‚ú§" "‚úú" "‚óÜ" "‚ñ∂")
        org-modern-table-vertical 1
        org-modern-table-horizontal 0.2
        org-modern-list '((43 . "‚û§")
                          (45 . "‚Äì")
                          (42 . "‚Ä¢"))
        org-modern-todo-faces
        '(("TODO" :inverse-video t :inherit org-todo)
          ("PROJ" :inverse-video t :inherit +org-todo-project)
          ("STRT" :inverse-video t :inherit +org-todo-active)
          ("[-]"  :inverse-video t :inherit +org-todo-active)
          ("HOLD" :inverse-video t :inherit +org-todo-onhold)
          ("WAIT" :inverse-video t :inherit +org-todo-onhold)
          ("[?]"  :inverse-video t :inherit +org-todo-onhold)
          ("KILL" :inverse-video t :inherit +org-todo-cancel)
          ("NO"   :inverse-video t :inherit +org-todo-cancel))
        org-modern-footnote
        (cons nil (cadr org-script-display))
        org-modern-progress nil
        org-modern-priority nil
        org-modern-horizontal-rule (make-string 36 ?‚îÄ)
        org-modern-keyword
        '((t . t)
          ("email" . #("ÓÉ°" 0 1 (display (raise -0.14))))
          ("property" . "‚ò∏")
          ("options" . "‚å•")
          ("startup" . "‚èª")
          ("bind" . #("ÓÖó" 0 1 (display (raise -0.1))))
          ("bibliography" . "ÔêÖ")
          ("print_bibliography" . #("Óïã" 0 1 (display (raise -0.1))))
          ("cite_export" . "ÔêÖ‚Æ≠")
          ("print_glossary" . #("Óïã·¥¨·∂ª" 0 1 (display (raise -0.1))))
          ("glossary_sources" . #("ÓÅì" 0 1 (display (raise -0.14))))
          ("include" . "‚á§")
          ("setupfile" . "‚áö")
          ("html_head" . "üÖ∑")
          ("html" . "üÖó")
          ("latex_class" . "üÑª")
          ("latex_class_options" . #("üÑªÓ¢∏" 1 2 (display (raise -0.14))))
          ("latex_header" . "üÖª")
          ("latex_header_extra" . "üÖª‚Å∫")
          ("latex" . "üÖõ")
          ("beamer_theme" . "üÑ±")
          ("beamer_color_theme" . #("üÑ±Óêä" 1 2 (display (raise -0.12))))
          ("beamer_header" . "üÖ±")
          ("beamer" . "üÖë")
          ("attr_latex" . "üÑõ")
          ("attr_html" . "üÑó")
          ("attr_org" . "‚í™")
          ("name" . "‚Åç")
          ("header" . "‚Ä∫")
          ("caption" . "‚ò∞")))
  (custom-set-faces! '(org-modern-statistics :inherit org-checkbox-statistics-todo)))

#+end_src

** PDF
I'm using pdf-tools because it's the most complete option out there.
The following snippet solves a issue I've encountered when selecting text.
#+begin_src emacs-lisp :tangle yes
(add-hook 'pdf-view-mode-hook
              (lambda () (add-hook 'evil-evilified-state-entry-hook
                                   (lambda (remove-hook 'activate-mark-hook 'evil-visual-activate-hook t))
                                   nil t)))
 #+end_src





** Python
*** Lsp
It's better to tweak the priority of =mspyls=.
#+begin_src emacs-lisp :tangle yes
(after! lsp-python-ms
  (set-lsp-priority! 'mspyls 1))
#+end_src
*** Black
To allow formatting of Python blocks in =org-mode= and elsewhere, add =python-black= to =packages.el=.
Then we configure it.

#+begin_src emacs-lisp :tangle yes
(use-package! python-black
  :after python
  :hook (python-mode . python-black-on-save-mode-enable-dwim))
#+end_src

#+RESULTS:
| python-black-on-save-mode-enable-dwim | er/add-python-mode-expansions | doom-modeline-env-setup-python | doom--setq-tab-width-for-python-mode-h | +python-use-correct-flycheck-executables-h | evil-collection-python-set-evil-shift-width | doom--enable-+web-django-mode-in-python-mode-h | pipenv-mode | +lookup-init--set-python-mode |
** TODO LaTeX (separate with comments)
Some time ago, I've installed vim in order to create fast latex notes through [[https://castel.dev/post/lecture-notes-1/][Gilles Castel Guide]]. What I didn't know at that time was that the same can be done in Emacs. Only easily and more efficiently!
Oh what a delight is to use Emacs!
Here, I've used the setup written by [[https://karthinks.com/software/latex-input-for-impatient-scholars/][Karthinks]] to better use LaTeX inside Emacs.
#+begin_src emacs-lisp :tangle yes
;; AucTeX settings - almost no changes
(use-package latex
  :ensure auctex
  :hook ((LaTeX-mode . prettify-symbols-mode))
  :bind (:map LaTeX-mode-map
         ("C-S-e" . latex-math-from-calc))
  :config
  ;; Format math as a Latex string with Calc
  (defun latex-math-from-calc ()
    "Evaluate `calc' on the contents of line at point."
    (interactive)
    (cond ((region-active-p)
           (let* ((beg (region-beginning))
                  (end (region-end))
                  (string (buffer-substring-no-properties beg end)))
             (kill-region beg end)
             (insert (calc-eval `(,string calc-language latex
                                          calc-prefer-frac t
                                          calc-angle-mode rad)))))
          (t (let ((l (thing-at-point 'line)))
               (end-of-line 1) (kill-line 0)
               (insert (calc-eval `(,l
                                    calc-language latex
                                    calc-prefer-frac t
                                    calc-angle-mode rad))))))))

(use-package preview
  :after latex
  :hook ((LaTeX-mode . preview-larger-previews))
  :config
  (defun preview-larger-previews ()
    (setq preview-scale-function
          (lambda () (* 1.25
                   (funcall (preview-scale-from-face)))))))

;; CDLatex settings
(use-package cdlatex
  :ensure t
  :hook (LaTeX-mode . turn-on-cdlatex)
  :bind (:map cdlatex-mode-map
              ("<tab>" . cdlatex-tab)))

;; Yasnippet settings
(use-package yasnippet
  :ensure t
  :hook ((LaTeX-mode . yas-minor-mode)
         (post-self-insert . my/yas-try-expanding-auto-snippets))
  :config
  (use-package warnings
    :config
    (cl-pushnew '(yasnippet backquote-change)
                warning-suppress-types
                :test 'equal))

  (setq yas-triggers-in-field t)

  ;; Function that tries to autoexpand YaSnippets
  ;; The double quoting is NOT a typo!
  (defun my/yas-try-expanding-auto-snippets ()
    (when (and (boundp 'yas-minor-mode) yas-minor-mode)
      (let ((yas-buffer-local-condition ''(require-snippet-condition . auto)))
        (yas-expand)))))

;; CDLatex integration with YaSnippet: Allow cdlatex tab to work inside Yas
;; fields
(use-package cdlatex
  :hook ((cdlatex-tab . yas-expand)
         (cdlatex-tab . cdlatex-in-yas-field))
  :config
  (use-package yasnippet
    :bind (:map yas-keymap
           ("<tab>" . yas-next-field-or-cdlatex)
           ("TAB" . yas-next-field-or-cdlatex))
    :config
    (defun cdlatex-in-yas-field ()
      ;; Check if we're at the end of the Yas field
      (when-let* ((_ (overlayp yas--active-field-overlay))
                  (end (overlay-end yas--active-field-overlay)))
        (if (>= (point) end)
            ;; Call yas-next-field if cdlatex can't expand here
            (let ((s (thing-at-point 'sexp)))
              (unless (and s (assoc (substring-no-properties s)
                                    cdlatex-command-alist-comb))
                (yas-next-field-or-maybe-expand)
                t))
          ;; otherwise expand and jump to the correct location
          (let (cdlatex-tab-hook minp)
            (setq minp
                  (min (save-excursion (cdlatex-tab)
                                       (point))
                       (overlay-end yas--active-field-overlay)))
            (goto-char minp) t))))

    (defun yas-next-field-or-cdlatex nil
      (interactive)
      "Jump to the next Yas field correctly with cdlatex active."
      (if
          (or (bound-and-true-p cdlatex-mode)
              (bound-and-true-p org-cdlatex-mode))
          (cdlatex-tab)
        (yas-next-field-or-maybe-expand)))))

;; Array/tabular input with org-tables and cdlatex
(use-package org-table
  :after cdlatex
  :bind (:map orgtbl-mode-map
              ("<tab>" . lazytab-org-table-next-field-maybe)
              ("TAB" . lazytab-org-table-next-field-maybe))
  :init
  (add-hook 'cdlatex-tab-hook 'lazytab-cdlatex-or-orgtbl-next-field 90)
  ;; Tabular environments using cdlatex
  (add-to-list 'cdlatex-command-alist '("smat" "Insert smallmatrix env"
                                       "\\left( \\begin{smallmatrix} ? \\end{smallmatrix} \\right)"
                                       lazytab-position-cursor-and-edit
                                       nil nil t))
  (add-to-list 'cdlatex-command-alist '("bmat" "Insert bmatrix env"
                                       "\\begin{bmatrix} ? \\end{bmatrix}"
                                       lazytab-position-cursor-and-edit
                                       nil nil t))
  (add-to-list 'cdlatex-command-alist '("pmat" "Insert pmatrix env"
                                       "\\begin{pmatrix} ? \\end{pmatrix}"
                                       lazytab-position-cursor-and-edit
                                       nil nil t))
  (add-to-list 'cdlatex-command-alist '("tbl" "Insert table"
                                        "\\begin{table}\n\\centering ? \\caption{}\n\\end{table}\n"
                                       lazytab-position-cursor-and-edit
                                       nil t nil))
  :config
  ;; Tab handling in org tables
  (defun lazytab-position-cursor-and-edit ()
    ;; (if (search-backward "\?" (- (point) 100) t)
    ;;     (delete-char 1))
    (cdlatex-position-cursor)
    (lazytab-orgtbl-edit))

  (defun lazytab-orgtbl-edit ()
    (advice-add 'orgtbl-ctrl-c-ctrl-c :after #'lazytab-orgtbl-replace)
    (orgtbl-mode 1)
    (open-line 1)
    (insert "\n|"))

  (defun lazytab-orgtbl-replace (_)
    (interactive "P")
    (unless (org-at-table-p) (user-error "Not at a table"))
    (let* ((table (org-table-to-lisp))
           params
           (replacement-table
            (if (texmathp)
                (lazytab-orgtbl-to-amsmath table params)
              (orgtbl-to-latex table params))))
      (kill-region (org-table-begin) (org-table-end))
      (open-line 1)
      (push-mark)
      (insert replacement-table)
      (align-regexp (region-beginning) (region-end) "\\([:space:]*\\)& ")
      (orgtbl-mode -1)
      (advice-remove 'orgtbl-ctrl-c-ctrl-c #'lazytab-orgtbl-replace)))

  (defun lazytab-orgtbl-to-amsmath (table params)
    (orgtbl-to-generic
     table
     (org-combine-plists
      '(:splice t
                :lstart ""
                :lend " \\\\"
                :sep " & "
                :hline nil
                :llend "")
      params)))

  (defun lazytab-cdlatex-or-orgtbl-next-field ()
    (when (and (bound-and-true-p orgtbl-mode)
               (org-table-p)
               (looking-at "[[:space:]]*\\(?:|\\|$\\)")
               (let ((s (thing-at-point 'sexp)))
                 (not (and s (assoc s cdlatex-command-alist-comb)))))
      (call-interactively #'org-table-next-field)
      t))

  (defun lazytab-org-table-next-field-maybe ()
    (interactive)
    (if (bound-and-true-p cdlatex-mode)
        (cdlatex-tab)
      (org-table-next-field))))
#+end_src

#+RESULTS:
: lazytab-org-table-next-field-maybe

Change the preview image size (use whatever number is best for you)
#+begin_src emacs-lisp :tangle yes
(add-hook 'LaTeX-mode-hook
          (defun preview-larger-previews ()
            (setq preview-scale-function
                  (lambda () (* 1.25
                           (funcall (preview-scale-from-face)))))))
#+end_src

YaSnippet complains if we use a snippet to edit the buffer directly. This is probably bad practice, but I haven‚Äôt had an issue yet. I suppress these warnings with
#+begin_src emacs-lisp :tangle yes
(with-eval-after-load 'warnings
  (cl-pushnew '(yasnippet backquote-change) warning-suppress-types
              :test 'equal))
#+end_src

Add the lsp server ~texlab~
#+begin_src emacs-lisp :tangle yes
(setq lsp-tex-server 'texlab)
#+end_src
